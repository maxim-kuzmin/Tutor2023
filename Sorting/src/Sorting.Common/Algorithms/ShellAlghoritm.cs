// Copyright (c) 2023 Maxim Kuzmin. All rights reserved. Licensed under the MIT License.

namespace Sorting.Common.Algorithms
{
    /// <summary>
    /// Алгоритм "Сортировка Шелла".
    /// Идея алгоритма такая же как у алгоритма сортировки вставками за
    /// одним лишь исключением: массив сортируется не целиком, а разбивается
    /// на группы, каждая из которых по очереди сортируется вставками.
    /// Размер элементов в каждой следующей группе увеличивается до
    /// тех пор, пока не будет включать в себя все элементы массива.
    /// Шаги:
    /// - Выбирается разница индексов между соседними элементами первой группы
    ///   элементов, так называемый "шаг". Его значение, как правило, берётся
    ///   равным половине длине массива.
    /// - Все элементы первой группы сортируются между собой по алгоритму
    ///   сортировки вставками.
    /// - Первоначальный шаг уменьшается вдвое и все элементы второй группы
    ///   также сортируются между собой по алгоритму сортировки вставками.    
    /// - И так далее до тех пор, пока шаг не станет равен единице. В этом случае
    ///   сортируются вставками уже все элементы массива.
    /// Ускорение сортировки по этому алгоритму по сравнению с алгоритмом вставками
    /// достигается за счёт того, что с каждым шагом количество операций обмена
    /// уменьшается, так как массив уже частично отсортирован на предыдущем шаге
    /// и с каждым шагом степень его упорядоченности увеличивается.
    /// В худшем случае (массив отсортирован в обратном порядке) сложность
    /// алгоритма квадратичная: O(N^2),
    /// так как используются 2 вложенных цикла: внешний с (N - 1) 
    /// и внутренний с (N / 2) итерациями, включающими в себя по
    /// одной операции сравнения и одной операции обмена:
    /// (N - 1) * (N / 2) * (2) = (N - 1) * (N) = O(N^2).
    /// В лучшем случае (массив уже отсортирован) и
    /// среднем случае (массив отсортирован в случайном порядке) сложность
    /// алгоритма линейно-логарифмическая: O(NlogN).
    /// Алгоритм считается достаточно быстрым и хоть проигрывает по скорости
    /// алгоритму быстрой сортировки, выигрывает у него по количеству
    /// потребляемой памяти. Поэтому, если памяти при использовании алгоритма
    /// быстрой сортировки будет не хватать, имеет смысл заменить его на
    /// сортировку Шелла.
    /// </summary>
    /// <typeparam name="T">Тип сортируемого значения.</typeparam>
    public class ShellAlghoritm<T> : Algorithm<T>
        where T : IComparable<T>
    {
        public ShellAlghoritm()
            : base("Shell")
        {
        }

        /// <inheritdoc/>
        protected sealed override void DoSort(T[] array)
        {
            for (int step = array.Length / 2; step > 0; step /= 2)
            {
                for (int iCur = step; iCur < array.Length; iCur++)
                {
                    for (int iCurBack = iCur; iCurBack >= step; iCurBack -= step)
                    {
                        if (Compare(array[iCurBack], array[iCurBack - step]) < 0)
                        {
                            Swap(ref array[iCurBack], ref array[iCurBack - step]);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
        }
    }
}
