// Copyright (c) 2023 Maxim Kuzmin. All rights reserved. Licensed under the MIT License.

namespace Sorting.Common.Algorithms
{
    /// <summary>
    /// Алгоритм "Быстрая сортировка".
    /// Шаги:
    /// - Выбирается произвольный, так называемый "опорный" элемент массива.
    /// - Остальные элементы массива переставляются таким образом, чтобы слева
    ///   от опорного элемента все элементы были меньше опорного, а справа -
    ///   больше.
    /// - С частями массива справа и слева от опорного элемента по отдельности
    ///   проводится то же самое, что и с элементами массива на предыдущих
    ///   двух шагах - выбирается опорный элемент, а остальные элементы выбранной
    ///   части массива расставляются слева и справа от опорного по тому же
    ///   принципу - слева меньшие, справа большие.
    /// - Эти шаги рекурсивно повторяются до тех пор, пока каждая часть массива,
    ///   разделённая опорным элементом, не будет пустой или состоять из одного
    ///   элемента.
    /// Эффективность алгоритма существенно зависит от выбора опорного элемента
    /// и, как следствие, количества операций разделения массива.
    /// В худшем случае при очередном разделении в одной из частей массива всегда
    /// будет только один элемент, то есть при каждом рекурсивном вызове больший
    /// массив будет на один элемент короче, чем в предыдущий раз.
    /// Такое может произойти, если в качестве опорного
    /// на каждом этапе будет выбран элемент либо наименьший, либо наибольший из
    /// всех обрабатываемых.
    /// При простейшем выборе опорного элемента - первого или
    /// последнего в массиве - такой эффект даст уже отсортированный
    /// (в прямом или обратном порядке) массив.
    /// В худшем случае сложность алгоритма квадратичная: O(N^2),
    /// в остальных случаях - линейно-логарифмическая: O(NlogN).
    /// Алгоритм считается одним из самых быстрых, но из-за рекурсии потребляет
    /// много памяти, что может привести к переполнению стека.
    /// </summary>
    /// <typeparam name="T">Тип сортируемого значения.</typeparam>
    public class QuickAlghoritm<T> : Algorithm<T>
        where T : IComparable<T>
    {
        public QuickAlghoritm()
            : base("Quick")
        {
        }

        /// <inheritdoc/>
        protected sealed override void DoSort(T[] array)
        {
            for (int step = array.Length / 2; step > 0; step /= 2)
            {
                for (int iCur = step; iCur < array.Length; iCur++)
                {
                    for (int iCurBack = iCur; iCurBack >= step; iCurBack -= step)
                    {
                        if (Compare(array[iCurBack], array[iCurBack - step]) < 0)
                        {
                            Swap(ref array[iCurBack], ref array[iCurBack - step]);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
        }

        private void Sort(T[] array, int iMin, int iMax)
        {

        }
    }
}
