// Copyright (c) 2023 Maxim Kuzmin. All rights reserved. Licensed under the MIT License.

namespace Sorting.Common.Algorithms
{
    /// <summary>
    /// Алгоритм "Сортировка выбором".
    /// Сложность квадратичная: O(N^2),
    /// так как используются 2 вложенных цикла: внешний с (N - 1) 
    /// и внутренний с (N / 2) итерациями, включающими в себя по
    /// одной операции сравнения и одной операции обмена:
    /// (N - 1) * (N / 2) * (2) = (N - 1) * (N) = O(N^2).
    /// Алгоритм состоит из следующих шагов:
    /// - Для начала определяем позицию минимального элемента массива;
    /// - Делаем обмен минимального элемента с элементом в начале массива.
    ///   Получается, что первый элемент массива уже отсортирован;
    /// - Уменьшаем рабочую область массива, отбрасывая первый элемент,
    ///   а для подмассива который получился, повторяем сортировку.
    /// Таким образом, упорядоченная часть массива формируется в его начале.
    /// Алгоритм эффективен, когда когда элементов массива не много.
    /// </summary>
    /// <typeparam name="T">Тип сортируемого значения.</typeparam>
    public class SelectionAlghoritm<T> : Algorithm<T>
        where T : IComparable<T>
    {
        public SelectionAlghoritm()
            : base("Selection")
        {
        }

        /// <inheritdoc/>
        protected sealed override void DoSort(T[] array)
        {
            // Проходим по массиву, начиная с первого элемента.
            // iCur - индекс текущего элемента.
            for (int iCur = 0; iCur < array.Length - 1; iCur++)
            {
                // Считаем текущий элемент минимальным и запоминаем его индекс.
                int iMin = iCur;

                // Проходим по всем элементам, следующим за текущим.
                // iNext - индекс следующего элемента.
                for (int iNext = iCur + 1; iNext < array.Length; iNext++)
                {
                    // Если следующий элемент меньше минимального элемента,
                    if (Compare(array[iNext], array[iMin]) < 0)
                    {
                        // Считаем следующий элемент минимальным и запоминаем его индекс.
                        iMin = iNext;
                    }

                    // Если текущий элемент не совпадает с минимальным,
                    if (iCur != iMin)
                    {
                        // меняем местами текущий и минимальный элементы.
                        Swap(ref array[iCur], ref array[iMin]);
                    }
                }
            }
        }
    }
}
